---
title: "Relatório 4 - software metrics"
output: html_notebook
---



#RQ1. Are there correlations among software metrics?

##Base balanceada

```{r}
library(corrplot)

kernelDsb <- read.csv(file = "/home/christiano/Dropbox/trabalhos/disciplina_mineracao/aulas/04-05/random_undersampling/kernel_data_balanced.csv")

cm <- cor(kernelDsb[,1:27])

corrplot(cm, type = "upper", order = "hclust", 
         tl.col = "black", tl.srt = 45)

col<- colorRampPalette(c("blue", "white", "red"))(20)
heatmap(x = cm, col = col, symm = TRUE)

```


##Base não balanceada

```{r}
kernelDsu <- read.csv(file = "/home/christiano/Dropbox/trabalhos/disciplina_mineracao/aulas/04-05/unbalanced/kernel_data.csv")

cm <- cor(kernelDsu[,1:27])

corrplot(cm, type = "upper", order = "hclust", 
         tl.col = "black", tl.srt = 45)

col<- colorRampPalette(c("blue", "white", "red"))(20)
heatmap(x = cm, col = col, symm = TRUE)
```


#RQ2. Are the software metrics able to represent functions with reported vulnerabilities?

```{r}

library(ggplot2)
library(dplyr)

kernelDsbVulnerable <- kernelDsb %>% filter(Affected=="VULNERABLE")
kernelDsbNeutral <- kernelDsb %>% filter(Affected=="NEUTRAL")

kernelDsbVulnerable$Affected <- NULL
kernelDsbVulnerable$Fold <- NULL
kernelDsbNeutral$Affected <- NULL
kernelDsbNeutral$Fold <- NULL

dfPvalueResult <- data.frame()
i=1
for(column in names(kernelDsbNeutral)){
  pvalue <- wilcox.test(kernelDsbNonVulnerable[[column]], kernelDsbVulnerable[[column]])$p.value
  dfPvalueResult[i,"metrica"] <- column
  dfPvalueResult[i,"pvalue"] <- pvalue
  i <- i + 1
}
```

### Resultado do teste estatístico de wilcoxon das métricas "Vulnerable" e "Neutral"

```{r}
dfPvalueResult
```

A partir dos valores de p-value encontrados, verifica-se que todas as métricas são menores que 0,05, o que significa que estão na faixa de 95% de certeza de que as métricas são estatisticamente relevantes para a variável "Affected"

### Visualização da distribuição de algumas métricas em boxplot
```{r}
kernelDsb %>% ggplot(aes(Affected, AltCountLineCode)) + geom_boxplot() + scale_y_continuous(trans = "log2")
kernelDsb %>% ggplot(aes(Affected, CountInput)) + geom_boxplot() + scale_y_continuous(trans = "log2")
kernelDsb %>% ggplot(aes(Affected, CountLineBlank)) + geom_boxplot() + scale_y_continuous(trans = "log2")
kernelDsb %>% ggplot(aes(Affected, CountLineCodeDecl)) + geom_boxplot() + scale_y_continuous(trans = "log2")
kernelDsb %>% ggplot(aes(Affected, CountLineComment)) + geom_boxplot() + scale_y_continuous(trans = "log2")
kernelDsb %>% ggplot(aes(Affected, CountLinePreprocessor)) + geom_boxplot() + scale_y_continuous(trans = "log2")
kernelDsb %>% ggplot(aes(Affected, CountPath)) + geom_boxplot() + scale_y_continuous(trans = "log2")
kernelDsb %>% ggplot(aes(Affected, CountStmt)) + geom_boxplot() + scale_y_continuous(trans = "log2")
kernelDsb %>% ggplot(aes(Affected, CountStmtEmpty)) + geom_boxplot() + scale_y_continuous(trans = "log2")
kernelDsb %>% ggplot(aes(Affected, Cyclomatic)) + geom_boxplot() + scale_y_continuous(trans = "log2")
kernelDsb %>% ggplot(aes(Affected, CyclomaticStrict)) + geom_boxplot() + scale_y_continuous(trans = "log2")
kernelDsb %>% ggplot(aes(Affected, Knots)) + geom_boxplot() + scale_y_continuous(trans = "log2")
  
  kernelDsb %>% ggplot(aes(Affected, MaxNesting)) + geom_boxplot() + scale_y_continuous(trans = "log2")
  print(column)

  names(kernelDsb)
  
  
  kernelDsb %>% ggplot(kernelDsb[,c("Affected","AltCountLineCode")]) + geom_boxplot(aes("Affected","AltCountLineCode")) + scale_y_continuous(trans = "log2")
```

#RQ3. How effective are machine learning techniques to predict vulnerable functions? 

```{r}



```

